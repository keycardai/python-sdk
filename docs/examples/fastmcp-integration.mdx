---
title: "FastMCP Integration"
description: "How to use Keycard OAuth with FastMCP servers for automated token exchange"
---

# FastMCP Integration

Simple examples showing how to use Keycard OAuth components with FastMCP for automated token exchange.

## Installation

```bash
uv add keycardai-mcp-fastmcp keycardai-oauth fastmcp
```

## Core Components

### 1. Auth Provider

Handles JWT authentication, user verification, and provides the grant decorator for token exchange:

```python
from keycardai.mcp.integrations.fastmcp import AuthProvider

# Basic setup
auth_provider = AuthProvider(
    zone_id="your-zone-id",
    mcp_server_name="My Server",
    mcp_base_url="http://localhost:8000/"
)

# Get RemoteAuthProvider for FastMCP
auth = auth_provider.get_remote_auth_provider()
```

### 2. Grant Decorator

Automatically exchanges user tokens for resource-specific tokens:

```python
from fastmcp import Context

@auth_provider.grant("https://api.example.com")
async def my_tool(ctx: Context):
    # Access tokens through context namespace
    access_context = ctx.get_state("keycardai")
    
    # Check for errors
    if access_context.has_errors():
        return {"error": "Failed to obtain access token"}
    
    # Get the token
    token = access_context.access("https://api.example.com").access_token
    return {"token": token}
```

### 3. Delegated Access with Client Credentials

For production use with delegated access to external APIs:

```python
from keycardai.mcp.integrations.fastmcp import AuthProvider, ClientSecret, BasicAuth
import os

auth_provider = AuthProvider(
    zone_id="your-zone-id",
    mcp_server_name="My Server",
    mcp_base_url="http://localhost:8000/",
    application_credential=ClientSecret((
        os.getenv("KEYCARD_CLIENT_ID"),
        os.getenv("KEYCARD_CLIENT_SECRET")
    ))
)
```

**Why this approach is best:**

- ✅ **Unified interface**: Single AuthProvider for both authentication and authorization
- ✅ **Protocol-based**: Supports multiple credential types (ClientSecret, WebIdentity, EKSWorkloadIdentity)
- ✅ **Type-safe**: Better autocomplete and type hints
- ✅ **Error handling**: Built-in error tracking per resource

## Basic Server Setup

```python
import os
from fastmcp import FastMCP, Context
from keycardai.mcp.integrations.fastmcp import (
    AuthProvider,
    AccessContext,
    ClientSecret,
)
import httpx

# Configure auth provider with client credentials for delegated access
auth_provider = AuthProvider(
    zone_id="your-zone-id",
    mcp_server_name="My Server",
    mcp_base_url="http://localhost:8000/",
    application_credential=ClientSecret((
        os.getenv("KEYCARD_CLIENT_ID"),
        os.getenv("KEYCARD_CLIENT_SECRET")
    ))
)

# Get RemoteAuthProvider for FastMCP
auth = auth_provider.get_remote_auth_provider()

# Create authenticated FastMCP server
mcp = FastMCP("My Server", auth=auth)

# Define tool with automatic token exchange
@mcp.tool()
@auth_provider.grant("https://www.googleapis.com/calendar/v3")
async def get_calendar_events(ctx: Context, maxResults: int = 10) -> dict:
    """Get user's calendar events."""
    # Get access context
    access_context: AccessContext = ctx.get_state("keycardai")
    
    # Check for errors
    if access_context.has_errors():
        return {"error": f"Token exchange failed: {access_context.get_errors()}"}
    
    # Get the token
    token = access_context.access("https://www.googleapis.com/calendar/v3").access_token
    
    # Make API call
    async with httpx.AsyncClient() as client:
        response = await client.get(
            "https://www.googleapis.com/calendar/v3/calendars/primary/events",
            headers={"Authorization": f"Bearer {token}"},
            params={"maxResults": maxResults}
        )
        response.raise_for_status()
        return response.json()

# Run server
if __name__ == "__main__":
    mcp.run(transport="streamable-http")
```

## Configuration

Set environment variables:

```bash
export ZONE_URL="https://your-zone.keycard.cloud"
export MCP_SERVER_URL="https://your-server.com/mcp"
export MCP_SERVER_NAME="My Server"
```

## Multiple Resource Access

Access multiple APIs with a single decorator:

```python
@mcp.tool()
@auth_provider.grant(["https://www.googleapis.com/calendar/v3", "https://www.googleapis.com/drive/v3"])
async def get_calendar_and_drive(ctx: Context):
    access_context: AccessContext = ctx.get_state("keycardai")
    
    # Check for errors
    if access_context.has_errors():
        return {"error": f"Token exchange failed: {access_context.get_errors()}"}
    
    # Get tokens for both resources
    calendar_token = access_context.access("https://www.googleapis.com/calendar/v3").access_token
    drive_token = access_context.access("https://www.googleapis.com/drive/v3").access_token
    
    return {
        "calendar_headers": {"Authorization": f"Bearer {calendar_token}"},
        "drive_headers": {"Authorization": f"Bearer {drive_token}"}
    }

# Or access them separately with single resource grants
@mcp.tool()
@auth_provider.grant("https://www.googleapis.com/calendar/v3")
async def get_calendar(ctx: Context):
    access_context: AccessContext = ctx.get_state("keycardai")
    
    if access_context.has_errors():
        return {"error": "Token exchange failed"}
    
    token = access_context.access("https://www.googleapis.com/calendar/v3").access_token
    return {"calendar_headers": {"Authorization": f"Bearer {token}"}}
```

## Error Handling

```python
import httpx
from keycardai.mcp.server.exceptions import ResourceAccessError

@mcp.tool()
@auth_provider.grant("https://api.example.com")
async def api_call(ctx: Context):
    # Get access context
    access_context: AccessContext = ctx.get_state("keycardai")
    
    # Check for token exchange errors
    if access_context.has_errors():
        errors = access_context.get_errors()
        return {
            "error": "Failed to obtain access token",
            "details": errors
        }
    
    try:
        # Get token and make API call
        token = access_context.access("https://api.example.com").access_token
        
        async with httpx.AsyncClient() as client:
            response = await client.get(
                "https://api.example.com/data",
                headers={"Authorization": f"Bearer {token}"}
            )
            response.raise_for_status()
            return response.json()
    except ResourceAccessError as e:
        return {"error": f"Resource access error: {e}"}
    except httpx.HTTPError as e:
        return {"error": f"API error: {e}"}
    except Exception as e:
        return {"error": f"Unexpected error: {e}"}
```

